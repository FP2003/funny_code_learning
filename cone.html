<!DOCTYPE html>
<html>
<head>
    <title>WebGL - 3D Cone Example</title>
    <meta charset='UTF-8'>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background: #f0f0f0;
        }
        canvas { 
            border: 2px solid black;
            display: block;
            margin: 20px auto;
        }
        #top {
            text-align: center;
            padding: 20px;
        }
    </style>

    <!-- Shaders -->
    <script id="shader-fs" type="x-shader/x-fragment">
        precision mediump float;
        
        void main(void) {
            gl_FragColor = vec4(0.5, 0.9, 0.2, 1.0); //Green
        }
    </script>

    <script id="shader-vs" type="x-shader/x-vertex">
        attribute vec3 aVertexPosition;
        uniform mat4 uMVMatrix;
        uniform mat4 uPMatrix;

        void main(void) {
            gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
            gl_PointSize = 3.0;
        }
    </script>

    <script type="text/javascript">
        // Matrix operations
        const mat4 = {
            create: function() {
                return new Float32Array([
                    1, 0, 0, 0,
                    0, 1, 0, 0,
                    0, 0, 1, 0,
                    0, 0, 0, 1
                ]);
            },
            perspective: function(fovy, aspect, near, far, out) {
                const f = 1.0 / Math.tan(fovy / 2);
                out[0] = f / aspect;
                out[1] = 0;
                out[2] = 0;
                out[3] = 0;
                out[4] = 0;
                out[5] = f;
                out[6] = 0;
                out[7] = 0;
                out[8] = 0;
                out[9] = 0;
                out[10] = (far + near) / (near - far);
                out[11] = -1;
                out[12] = 0;
                out[13] = 0;
                out[14] = (2 * far * near) / (near - far);
                out[15] = 0;
                return out;
            },
            identity: function(out) {
                out[0] = 1;
                out[1] = 0;
                out[2] = 0;
                out[3] = 0;
                out[4] = 0;
                out[5] = 1;
                out[6] = 0;
                out[7] = 0;
                out[8] = 0;
                out[9] = 0;
                out[10] = 1;
                out[11] = 0;
                out[12] = 0;
                out[13] = 0;
                out[14] = 0;
                out[15] = 1;
                return out;
            },
            translate: function(out, v) {
                out[12] = out[0] * v[0] + out[4] * v[1] + out[8] * v[2] + out[12];
                out[13] = out[1] * v[0] + out[5] * v[1] + out[9] * v[2] + out[13];
                out[14] = out[2] * v[0] + out[6] * v[1] + out[10] * v[2] + out[14];
                out[15] = out[3] * v[0] + out[7] * v[1] + out[11] * v[2] + out[15];
                return out;
            }
        };

        // WebGL variables
        var gl = null;
        var prg = null;
        var c_width = 0;
        var c_height = 0;

        var coneVertexBuffer = null; //The vertex buffer for the cone
        var coneIndexBuffer = null; // The index buffer for the cone

        var indices = [];
        var vertices = [];

        var mvMatrix = mat4.create(); // The Model-View matrix
        var pMatrix = mat4.create(); // The projection matrix

        /**
        * The program contains a series of instructions that tell the Graphic Processing Unit (GPU)
        * what to do with every vertex and fragment that we pass it. (more about this on chapter 3)
        * The vertex shader and the fragment shader together are called the program.
        */
        function getShader(gl, id) {
            var script = document.getElementById(id);
            if (!script) {
                return null;
            }

            var shader;
            if (script.type === 'x-shader/x-fragment') {
                shader = gl.createShader(gl.FRAGMENT_SHADER);
            } else if (script.type === 'x-shader/x-vertex') {
                shader = gl.createShader(gl.VERTEX_SHADER);
            } else {
                return null;
            }

            gl.shaderSource(shader, script.text);
            gl.compileShader(shader);

            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                alert('Shader compile error: ' + gl.getShaderInfoLog(shader));
                return null;
            }

            return shader;
        }

        function initProgram() {
            var fgShader = getShader(gl, 'shader-fs');
            var vxShader = getShader(gl, 'shader-vs');
            if (!fgShader || !vxShader) {
                console.error('Failed to get shaders');
                return false;
            }

            prg = gl.createProgram();
            gl.attachShader(prg, vxShader);
            gl.attachShader(prg, fgShader);
            gl.linkProgram(prg);

            if (!gl.getProgramParameter(prg, gl.LINK_STATUS)) {
                console.error('Program link error: ' + gl.getProgramInfoLog(prg));
                return false;
            }

            gl.useProgram(prg);

            // Get attribute and uniform locations
            prg.vertexPositionAttribute = gl.getAttribLocation(prg, 'aVertexPosition');
            if (prg.vertexPositionAttribute === -1) {
                console.error('Failed to get attribute location for aVertexPosition');
                return false;
            }
            
            prg.pMatrixUniform = gl.getUniformLocation(prg, 'uPMatrix');
            prg.mvMatrixUniform = gl.getUniformLocation(prg, 'uMVMatrix');
            
            if (!prg.pMatrixUniform || !prg.mvMatrixUniform) {
                console.error('Failed to get uniform locations');
                return false;
            }

            // Enable the vertex attribute
            gl.enableVertexAttribArray(prg.vertexPositionAttribute);
            return true;
        }		

        /**
        * Creates the buffers that contain the geometry of the cone
        */
        function initBuffers() {

            vertices = [
                1.5, 0, 0,
                -1.5, 1, 0,
                -1.5, 0.809017, 0.587785,
                -1.5, 0.309017, 0.951057,
                -1.5, -0.309017, 0.951057,
                -1.5, -0.809017, 0.587785,
                -1.5, -1, 0,
                -1.5, -0.809017, -0.587785,
                -1.5, -0.309017, -0.951057,
                -1.5, 0.309017, -0.951057,
                -1.5, 0.809017, -0.587785
            ];

            indices = [
                0, 1, 2,
                0, 2, 3,
                0, 3, 4,
                0, 4, 5,
                0, 5, 6,
                0, 6, 7,
                0, 7, 8,
                0, 8, 9,
                0, 9, 10,
                0, 10, 1
            ];

            //The following code snippet creates a vertex buffer and binds data to it
            coneVertexBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, coneVertexBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
            
            
            coneIndexBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, coneIndexBuffer);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);
            
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
            gl.bindBuffer(gl.ARRAY_BUFFER,null);

        }

        /**
        * Draws the scene
        */
        function drawScene(){

            gl.clearColor(0.0, 0.0, 0.0, 1.0);
            gl.enable(gl.DEPTH_TEST);

            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            gl.viewport(0,0,c_width, c_height);

            mat4.perspective(45, c_width / c_height, 0.1, 10000.0, pMatrix);
            mat4.identity(mvMatrix);
            mat4.translate(mvMatrix, [0.0, 0.0, -5.0]);

            gl.uniformMatrix4fv(prg.pMatrixUniform, false, pMatrix);
            gl.uniformMatrix4fv(prg.mvMatrixUniform, false, mvMatrix);

            gl.bindBuffer(gl.ARRAY_BUFFER, coneVertexBuffer);
            gl.vertexAttribPointer(prg.vertexPositionAttribute, 3, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, coneIndexBuffer);
            gl.drawElements(gl.LINE_LOOP, indices.length, gl.UNSIGNED_SHORT, 0);
        }

        /**
        * Render Loop
        */
        function renderLoop() {
            requestAnimFrame(renderLoop);
            drawScene();
        }

        /**
        * Executes the WebGL application
        * This function is invoked on the onLoad event of the web page. 
        */
        function runWebGLApp() {
            const canvas = document.getElementById('canvas-element-id');
            if (!canvas) {
                alert('Canvas element not found!');
                return;
            }

            // Update canvas dimensions
            c_width = canvas.width;
            c_height = canvas.height;

            // Get WebGL context
            gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
            if (!gl) {
                alert('WebGL not supported');
                return;
            }

            // Initialize shaders and scene
            if (!initProgram()) {
                alert('Failed to initialize shaders');
                return;
            }

            initBuffers();
            renderLoop();
        }

        var rotation = 0.0;

        function drawScene() {
            gl.clearColor(0.0, 0.0, 0.0, 1.0)
            gl.enable(gl.DEPTH_TEST);

            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            gl.viewport(0, 0, c_width, c_height);

            mat4.perspective(45, c_width / c_height, 0.1, 10000.0, pMatrix);
            mat4.identity(mvMatrix);
            mat4.translate(mvMatrix, [0.0, 0.0, -5.0]);

            rotation += 0.01;
            // how it rotates (mathematical)
            mvMatrix[0] = Math.cos(rotation);
            mvMatrix[2] = -Math.sin(rotation);
            mvMatrix[8] = Math.sin(rotation);
            mvMatrix[10] = Math.cos(rotation);

            gl.uniformMatrix4fv(prg.pMatrixUniform, false, pMatrix);
            gl.uniformMatrix4fv(prg.mvMatrixUniform, false, mvMatrix);

            gl.bindBuffer(gl.ARRAY_BUFFER, coneVertexBuffer);
            gl.vertexAttribPointer(prg.vertexPositionAttribute, 3, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, coneIndexBuffer);
            gl.drawElements(gl.LINE_LOOP, indices.length, gl.UNSIGNED_SHORT, 0);
        }

        // Set up animation frame request
        window.requestAnimFrame = (function() {
            return window.requestAnimationFrame ||
                window.webkitRequestAnimationFrame ||
                window.mozRequestAnimationFrame ||
                function(callback) {
                    window.setTimeout(callback, 1000 / 60);
                };
        })();

        // Start the application when the page loads
        window.onload = runWebGLApp;
    </script>
</head>
<body>
    <div id='top'>
        <h1>WebGL 3D Cone Example</h1>
        <p>WebGL example showing a 3D cone rendered with line segments.</p>
    </div>

    <canvas id='canvas-element-id' width='480' height='400'>
        Your browser does not support the HTML5 canvas element.
    </canvas>
</body>
</html>
